const input = 
`../.. => .../#.#/...
#./.. => ..#/..#/#..
##/.. => .../#../..#
.#/#. => #../.../...
##/#. => #.#/.#./#..
##/## => ..#/#.#/..#
.../.../... => .#../#..#/#.../.#..
#../.../... => ..##/..##/.#.#/....
.#./.../... => ..##/..##/.###/##..
##./.../... => ..../.##./#.##/..#.
#.#/.../... => ####/#.##/#.##/#.#.
###/.../... => #..#/..#./..../##.#
.#./#../... => ..#./.#../...#/#.##
##./#../... => ..../#.##/#..#/.#..
..#/#../... => ##.#/####/###./###.
#.#/#../... => ..../#.##/.###/#.#.
.##/#../... => ..#./##.#/####/..##
###/#../... => ..#./.##./...#/..#.
.../.#./... => .###/#.../.#../####
#../.#./... => ###./.#.#/#.##/##.#
.#./.#./... => ..##/..#./###./..#.
##./.#./... => #..#/..#./###./...#
#.#/.#./... => #.../##.#/#.##/#..#
###/.#./... => ...#/#..#/####/##.#
.#./##./... => #.##/#.##/..../#.#.
##./##./... => ..##/###./..#./####
..#/##./... => ..../##../##.#/.##.
#.#/##./... => ##../####/####/.#.#
.##/##./... => ..../##.#/.###/##..
###/##./... => .#../#.#./.#../..##
.../#.#/... => ####/#.#./..##/#..#
#../#.#/... => .#../.#../#..#/....
.#./#.#/... => ..##/.##./####/#.#.
##./#.#/... => ..#./###./.#../....
#.#/#.#/... => ..#./..#./...#/#...
###/#.#/... => ###./.#../##../####
.../###/... => #.##/####/####/..##
#../###/... => .#.#/...#/###./...#
.#./###/... => ..../.#.#/.#../....
##./###/... => ...#/.###/..../.##.
#.#/###/... => ..##/###./.#../#..#
###/###/... => .###/..#./..#./.###
..#/.../#.. => .##./###./####/#.#.
#.#/.../#.. => ####/#.../#.../..##
.##/.../#.. => ###./#..#/..#./.#..
###/.../#.. => .###/.##./#.#./.###
.##/#../#.. => ##.#/...#/.#.#/...#
###/#../#.. => #.##/..#./..../#..#
..#/.#./#.. => #..#/##.#/.##./####
#.#/.#./#.. => ###./..##/#..#/#..#
.##/.#./#.. => .#../..../...#/...#
###/.#./#.. => .#../##../.###/..#.
.##/##./#.. => ##../..##/##../##.#
###/##./#.. => #.##/#..#/.###/####
#../..#/#.. => ##.#/####/#.../..##
.#./..#/#.. => #..#/..../..../###.
##./..#/#.. => #..#/##.#/##.#/#.#.
#.#/..#/#.. => .###/##.#/####/#...
.##/..#/#.. => ####/.##./...#/#..#
###/..#/#.. => .#.#/####/##.#/...#
#../#.#/#.. => ..##/.##./..##/##..
.#./#.#/#.. => #.../##../..##/..#.
##./#.#/#.. => ...#/##.#/#..#/.#..
..#/#.#/#.. => #.#./##../#.##/###.
#.#/#.#/#.. => ##../##.#/#.#./....
.##/#.#/#.. => ####/...#/####/.#..
###/#.#/#.. => ..../.#../.#../....
#../.##/#.. => .#.#/..#./#..#/.###
.#./.##/#.. => #.../.#.#/.###/.##.
##./.##/#.. => #.#./#.#./.#../###.
#.#/.##/#.. => ####/##../.##./####
.##/.##/#.. => #.../#.#./#.##/###.
###/.##/#.. => ####/####/..../####
#../###/#.. => ####/.##./...#/##.#
.#./###/#.. => .#../#.##/#..#/..##
##./###/#.. => #.#./..##/#.../..##
..#/###/#.. => #.##/.###/#.#./###.
#.#/###/#.. => #.##/#.##/..../#..#
.##/###/#.. => .##./#.#./..##/####
###/###/#.. => .##./#..#/#.../###.
.#./#.#/.#. => #.#./#..#/#..#/##.#
##./#.#/.#. => ...#/#.#./##.#/###.
#.#/#.#/.#. => ##.#/..##/##.#/#.##
###/#.#/.#. => .#.#/..#./##../.##.
.#./###/.#. => #..#/..#./..##/#...
##./###/.#. => ####/.#.#/####/..#.
#.#/###/.#. => #.#./..##/##../#..#
###/###/.#. => ...#/..../..../#.#.
#.#/..#/##. => ..#./.##./###./.#.#
###/..#/##. => #.../###./...#/####
.##/#.#/##. => ..../..../.###/##..
###/#.#/##. => ##../..../#.#./.##.
#.#/.##/##. => .#.#/##../..##/#.#.
###/.##/##. => ###./####/...#/.#..
.##/###/##. => ..##/#.../..##/.#.#
###/###/##. => ..##/...#/.###/.#..
#.#/.../#.# => ..##/#.../##.#/....
###/.../#.# => #.##/#..#/..../##..
###/#../#.# => #.../..../##.#/..#.
#.#/.#./#.# => ###./..##/.#../.##.
###/.#./#.# => ..../#..#/.###/#..#
###/##./#.# => .#.#/###./##.#/.###
#.#/#.#/#.# => ..../..../.##./#..#
###/#.#/#.# => .###/.#.#/...#/.###
#.#/###/#.# => .#.#/##../.#../.#..
###/###/#.# => .#.#/.##./#.##/....
###/#.#/### => ..#./..#./..#./..##
###/###/### => ##.#/..##/.#.#/....`;


const generateRotations = (arr) => {
  const rotationsArr = [];
  const arrLen = arr.length;
  for(let i = 0;i < arrLen;i++){
    const [ruleIn, ruleOut] = arr[i];
    const inLen = ruleIn.length;
    let flipped = ruleIn.map(v => Array.from(v));
    for(let x = 0;x < inLen;x++){
      for(let y = 0;y < inLen;y++){
        flipped[x][y] = ruleIn[x][inLen - y - 1];
      }
    }
    for(let turn = 0;turn < 2;turn++){
      let rotatedIn = (turn === 0) ? ruleIn : flipped;
      for(let i = 0;i < 4;i++){
        const curRotation = rotatedIn.map(v => Array.from(v));
        rotationsArr.push([curRotation.toString(), ruleOut]);
        for(let x = 0;x < inLen;x++){
          for(let y = 0;y < inLen;y++){
            rotatedIn[x][y] = curRotation[inLen - y - 1][x];
          }
        }
      }
    }
  }
  return rotationsArr;
};

const inputLines = input.split('\n');
const baseInputTwo = inputLines
                      .filter(ln => ln.split('/').length === 4)
                      .map(ln => ln
                                  .split(' => ')
                                  .map(side => side.split('/')
                                  .map(row => row.split(''))));
const inputTwo = generateRotations(baseInputTwo);

const baseInputThree = inputLines
                        .filter(ln => ln.split('/').length === 6)
                        .map(ln => ln
                                    .split(' => ')
                                    .map(side => side.split('/')
                                    .map(row => row.split(''))));
const inputThree = generateRotations(baseInputThree);

const rulesTwo = new Map(inputTwo);
const rulesThree = new Map(inputThree);

const genGrid = function*(){
  let grid = [['.', '#', '.'],
              ['.', '.', '#'],
              ['#', '#', '#']];

  while(true){
    const curSize = grid.length;
    const sectorSize = (curSize % 2 === 0) ? 2 : 3;
    const sectorQty = curSize / sectorSize;
    const nextSize = (sectorSize + 1) * sectorQty;
    const ruleMap = (sectorSize === 2) ? rulesTwo : rulesThree;
    const newGrid = new Array(nextSize)
                      .fill(null)
                      .map(v => new Array(nextSize));
    for(let i = 0; i < ~~(curSize/sectorSize);i++){
      for(let j = 0; j < ~~(curSize/sectorSize);j++){
        const subGrid = grid.filter((v, idx) => (idx < (i + 1) * sectorSize) &&
                                                (idx >= i * sectorSize))
                            .map(row => row.filter((v, idx) => (idx < (j + 1) * sectorSize) &&
                                                               (idx >= j * sectorSize)));
        const rule = subGrid.toString();
        const transform = ruleMap.get(rule);
        const transformLen = transform.length;
        for(let nI = 0;nI < transformLen;nI++){
          for(let nJ = 0;nJ < transformLen;nJ++){
            newGrid[i * transformLen + nI][j * transformLen + nJ] = transform[nI][nJ];
          }
        }
      }
    }
    grid = newGrid;
    yield newGrid;
  }
}

const iters = 5;
let grid;
let gridGen = genGrid();
for(let i = 0; i < iters;i++){
  grid = gridGen.next().value;
}
let total = 0;
grid.forEach(row => {
  total += row.reduce((qty, val) => qty + ((val === '#') ? 1 : 0), 0);
});
console.log(total);
